"""
WebSocket Manager for Real-Time Push Notifications

Sends real-time updates to frontend when:
- Questions are ready for Stage 1 review
- Stage 1 review progress updates
- Gemini testing completes (Stage 2 ready)
- Pipeline state changes
"""
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, List, Set
import json
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class ConnectionManager:
    """
    Manages WebSocket connections for push notifications
    
    Architecture:
    - Connections organized by video_id
    - Multiple clients can subscribe to same video
    - Broadcast events to all subscribers
    """
    
    def __init__(self):
        # video_id -> Set of WebSocket connections
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        
        # Track connection metadata
        self.connection_info: Dict[WebSocket, Dict] = {}
        
        logger.info("WebSocket ConnectionManager initialized")
    
    async def connect(self, websocket: WebSocket, video_id: str, client_id: str = None):
        """
        Accept new WebSocket connection
        
        Args:
            websocket: WebSocket connection
            video_id: Video ID to subscribe to
            client_id: Optional client identifier
        """
        await websocket.accept()
        
        # Add to active connections
        if video_id not in self.active_connections:
            self.active_connections[video_id] = set()
        
        self.active_connections[video_id].add(websocket)
        
        # Store metadata
        self.connection_info[websocket] = {
            'video_id': video_id,
            'client_id': client_id,
            'connected_at': datetime.utcnow().isoformat()
        }
        
        logger.info(f"WebSocket connected: video={video_id}, client={client_id}")
        
        # Send connection confirmation
        await websocket.send_json({
            'type': 'connection_established',
            'video_id': video_id,
            'timestamp': datetime.utcnow().isoformat()
        })
    
    def disconnect(self, websocket: WebSocket):
        """
        Remove WebSocket connection
        
        Args:
            websocket: WebSocket connection to remove
        """
        if websocket in self.connection_info:
            info = self.connection_info[websocket]
            video_id = info['video_id']
            
            # Remove from active connections
            if video_id in self.active_connections:
                self.active_connections[video_id].discard(websocket)
                
                # Clean up empty sets
                if not self.active_connections[video_id]:
                    del self.active_connections[video_id]
            
            # Remove metadata
            del self.connection_info[websocket]
            
            logger.info(f"WebSocket disconnected: video={video_id}")
    
    async def send_personal_message(self, message: dict, websocket: WebSocket):
        """
        Send message to specific WebSocket
        
        Args:
            message: Message dictionary
            websocket: Target WebSocket
        """
        try:
            await websocket.send_json(message)
        except Exception as e:
            logger.error(f"Failed to send personal message: {e}")
            self.disconnect(websocket)
    
    async def broadcast_to_video(self, video_id: str, message: dict):
        """
        Broadcast message to all connections for a video
        
        Args:
            video_id: Target video ID
            message: Message dictionary to broadcast
        """
        if video_id not in self.active_connections:
            logger.debug(f"No active connections for video {video_id}")
            return
        
        # Add timestamp if not present
        if 'timestamp' not in message:
            message['timestamp'] = datetime.utcnow().isoformat()
        
        # Send to all connections
        disconnected = []
        for websocket in self.active_connections[video_id]:
            try:
                await websocket.send_json(message)
            except Exception as e:
                logger.error(f"Failed to broadcast to connection: {e}")
                disconnected.append(websocket)
        
        # Clean up disconnected clients
        for websocket in disconnected:
            self.disconnect(websocket)
        
        logger.info(
            f"Broadcasted '{message.get('type')}' to {len(self.active_connections.get(video_id, []))} clients "
            f"for video {video_id}"
        )
    
    async def notify_stage1_ready(self, video_id: str, total_questions: int):
        """
        Notify that questions are ready for Stage 1 review
        
        Args:
            video_id: Video ID
            total_questions: Number of questions ready for review
        """
        await self.broadcast_to_video(video_id, {
            'type': 'stage1_ready',
            'video_id': video_id,
            'total_questions': total_questions,
            'message': f'{total_questions} questions ready for review'
        })
    
    async def notify_stage1_progress(
        self,
        video_id: str,
        approved: int,
        rejected: int,
        pending: int,
        total: int
    ):
        """
        Notify of Stage 1 review progress update
        
        Args:
            video_id: Video ID
            approved: Number approved
            rejected: Number rejected
            pending: Number pending
            total: Total questions
        """
        await self.broadcast_to_video(video_id, {
            'type': 'stage1_progress',
            'video_id': video_id,
            'approved': approved,
            'rejected': rejected,
            'pending': pending,
            'total': total,
            'progress_percent': ((approved + rejected) / total * 100) if total > 0 else 0
        })
    
    async def notify_stage1_complete(self, video_id: str):
        """
        Notify that Stage 1 review is complete
        
        Args:
            video_id: Video ID
        """
        await self.broadcast_to_video(video_id, {
            'type': 'stage1_complete',
            'video_id': video_id,
            'message': 'All questions reviewed. Starting validation...'
        })
    
    async def notify_validation_progress(self, video_id: str, current: int, total: int):
        """
        Notify of validation progress
        
        Args:
            video_id: Video ID
            current: Current question being validated
            total: Total questions to validate
        """
        await self.broadcast_to_video(video_id, {
            'type': 'validation_progress',
            'video_id': video_id,
            'current': current,
            'total': total,
            'progress_percent': (current / total * 100) if total > 0 else 0
        })
    
    async def notify_gemini_testing_progress(self, video_id: str, current: int, total: int):
        """
        Notify of Gemini testing progress
        
        Args:
            video_id: Video ID
            current: Current question being tested
            total: Total questions to test
        """
        await self.broadcast_to_video(video_id, {
            'type': 'gemini_testing_progress',
            'video_id': video_id,
            'current': current,
            'total': total,
            'progress_percent': (current / total * 100) if total > 0 else 0
        })
    
    async def notify_stage2_ready(self, video_id: str, failures_count: int):
        """
        Notify that Stage 2 selection is ready (Gemini testing complete)
        
        Args:
            video_id: Video ID
            failures_count: Number of Gemini failures to choose from
        """
        await self.broadcast_to_video(video_id, {
            'type': 'stage2_ready',
            'video_id': video_id,
            'failures_count': failures_count,
            'message': f'{failures_count} Gemini failures ready for selection'
        })
    
    async def notify_pipeline_complete(self, video_id: str, excel_path: str):
        """
        Notify that pipeline is complete
        
        Args:
            video_id: Video ID
            excel_path: Path to generated Excel file
        """
        await self.broadcast_to_video(video_id, {
            'type': 'pipeline_complete',
            'video_id': video_id,
            'excel_path': excel_path,
            'message': 'Pipeline complete! Excel file ready for download.'
        })
    
    async def notify_error(self, video_id: str, error_message: str, stage: str):
        """
        Notify of pipeline error
        
        Args:
            video_id: Video ID
            error_message: Error description
            stage: Pipeline stage where error occurred
        """
        await self.broadcast_to_video(video_id, {
            'type': 'pipeline_error',
            'video_id': video_id,
            'error': error_message,
            'stage': stage
        })
    
    async def notify_regeneration_complete(
        self,
        video_id: str,
        question_id: str,
        new_question_id: str
    ):
        """
        Notify that question regeneration is complete
        
        Args:
            video_id: Video ID
            question_id: Original question ID
            new_question_id: Newly generated question ID
        """
        await self.broadcast_to_video(video_id, {
            'type': 'regeneration_complete',
            'video_id': video_id,
            'original_question_id': question_id,
            'new_question_id': new_question_id,
            'message': 'New question generated and ready for review'
        })
    
    def get_connection_count(self, video_id: str = None) -> int:
        """
        Get number of active connections
        
        Args:
            video_id: Optional video ID to filter by
            
        Returns:
            Number of active connections
        """
        if video_id:
            return len(self.active_connections.get(video_id, set()))
        else:
            return sum(len(conns) for conns in self.active_connections.values())
    
    def get_stats(self) -> Dict:
        """Get connection statistics"""
        return {
            'total_connections': self.get_connection_count(),
            'videos_with_connections': len(self.active_connections),
            'connections_by_video': {
                video_id: len(conns)
                for video_id, conns in self.active_connections.items()
            }
        }


# Global connection manager instance
manager = ConnectionManager()